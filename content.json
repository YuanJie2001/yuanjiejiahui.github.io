{"pages":[{},{},{}],"posts":[{"title":"语文期末","date":"2021-06-26T09:44:18.000Z","path":"2021/06/26/语文期末/","text":"语文期末 老师好,我是20软工四班,王佳慧.学号是201530404 这学期我修了大学语文这门课，总体感觉还不错。说高中语文的学习过程中，许多东西是你平时应试而不去学.那么到了大学，学习语文不再有应试的了。暂时放下平日课业的繁重，我完全是抱着享受的态度来的. 你可以用的思维去想问题，人再来评论你的对错，那些呆板的标准是应试而制定的。海阔凭鱼跃，天高任鸟飞，在大学语文的课堂里,你的思维可以尽情表达。 自古有言：“人生有涯，而知无涯。”可见学习也应是无止境的。我以为，学习大学语文，首先是为了培养我们对美的感受力，陶冶我们的性情，提高我们的文学艺术修养。而文学艺术在激发人的精神的丰富性、保存和发展人对世界的多样性想象方面，是其他东西不可替代的。在这个消费主义和功利主义喧嚣尘上的时代，人们的生活与心灵越来越粗糙化和粗鄙化，而文学艺术可以润泽我们的灵魂。大学语文就是一门带领大家赏析文学经典的课程，在赏析的过程中，我们可以陶冶情趣，提升境界，彻悟生命。同时，语文是一切学科的基础，无论想成为什么专业的人才，必须先学好语文；语文不仅是生命的工具，而且是提高人的气质修养和道德情操的重要途径； 通过老师带领我们走出僵化思维,充满活力.在语文课堂上,我们感悟儒道思想的玄妙;从诗经中感悟古人欣赏的态度;通过语文课的学习,从历史走向今天.使我了解到,我们所想的,所做的,所疑惑的…早在千年之前古人也已经历过.至此我也深刻理解违背历史经验的谆谆教诲而行,大部分都会失败!因为这是历史经验的积淀!无数辈人的结晶.他们留给我们的,传承至今的文化是不可比拟的财富!因此我非常感念,我有幸读到先人们的作品. 语文课最让我感到敬佩的人物是老子和苏轼.我的老家就是道家之源函谷关,深受”上善若水,泽被后世”的思想而奉行低调做人,高调做事.因此在这内卷严重的时代,学校举办很多的活动,和竞选.因此有失有得是必然!不是不争,而是知道什么该争,什么不该争;知道什么该为,什么不为!功遂身退，天之道也。这是我深受老子思想影响的地方. 对于苏轼,我一直都知道,他是不可多得全才!什么都会,而且在很多领域享负盛名!散文标志北宋古文运动的最高成就;开创豪放词风;创立苏尚艺书风,宋四家之一;烹饪一哥,自创东坡肉!;等等对于他只有敬佩和羡慕.他的豪放诗也时常勉励我”莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生!”.有时候会感到孤独,感觉学习学着忘着,很恐惧.这时听歌或者想起苏轼的这句话,我就又充满干劲! 这么多年来,通过语文的学习,我渐渐感悟我所追求的应该是可以留住的东西。这可以留住的东西就是，灵魂、思想、诗、和文。 https://www.cnblogs.com/shiddong/p/5793163.htmlpython资料库","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"","date":"2021-06-14T05:27:20.625Z","path":"2021/06/14/多线程详解(从概念到实际开发)/","text":"我列的提纲:参考宝典阿里手册本文,也将主要依据阿里巴巴java开发手册-编程规约-并发处理进行分析.**问题一:1.多线程解决的问题.2.详细理解多线程.(1)区分进程和线程(2)多线程的并发和并行的区别(3)多线程的运行逻辑(4)多线程的实现方法并择优(5)深入多线程的运行逻辑–&gt;多线程的调度和控制 问二:(1)高并发在实际开发经常存在(2)什么是高并发(3)依据12306解决高并发问题(4)比对方法和择优问三:(1)同步机制作用.(2)实际开发应用.** 1.多线程解决的问题 **渐入物联网时代,人工智能时代.日前,要解决大的吞吐量,爬取亿万级数据...提高效率不言而喻. 据悉多核情况下，使用多线程可能会提高效率.但是在实际情况中，使用多线程的方式会额外增加系统的开销。 相对于单核系统任务本身的资源消耗外，多线程应用还需要维护额外多线程特有的信息。 比如，线程本身的元数据，线程调度，线程上下文的切换等。 综上所述多线程如同,号称云计算时代最强的为解决高并发而生的go语言一样要解决的是高并发这一问题!** **同时没有多任务就不必要多线程** 2.详细理解多线程(1)区分进程和线程基本概念:进程是操作系统资源分配的基本单位.进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。 线程是处理器任务调度和执行的基本单位常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。 通俗版: 多线程可以让你在一条进程中同时刻进行不同任务.提高该进程的效率!如老板只负责给你钱,你办事. 1.你可以一个人干 2.也可以拿一部分钱雇人.但最终结果都要是给了该钱,办了该事. 也就是说线程是被包含于进程中.2也就是多线程的意思. 进程生命周期长于线程. (2)多线程的并发和并行区别并发:如只有一个内核,四个逻辑内核.那么多线程事实上是模拟出来的.只是计算机运行足够快,感觉像是多线程.这叫并发并行:两内核或以上.才有真正的多线程.真正独立的各自干各自,互不影响的这叫并行.如图(3)普通方法调用和多线程使用的区别: (4)多线程实现方法1)继承Thread类2)实现runnable接口3)实现Callable接口4)使用线程池规则:少用继承多用实现. 1)直接继承Thread类 1234567891011121314151617 //Thread类也实现了runnable接口,因此必须重写run()方法 class PrimeThread extends Thread &#123; long minPrime; PrimeThread(long minPrime) &#123; this.minPrime = minPrime; &#125;public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125;//然后，以下代码将创建一个线程并启动它运行： PrimeThread p = new PrimeThread(111); p.start(); 2)实现runnable接口 12345678910111213141516class PrimeRun implements Runnable &#123; long minPrime; PrimeRun(long minPrime) &#123; this.minPrime = minPrime; &#125; public void run() &#123; // compute primes larger than minPrime . . . &#125; &#125;//然后，以下代码将创建一个线程并启动它运行： //runnable没有继承Thread类,没有start方法,无法启动线程.因此有如下操作 PrimeRun p = new PrimeRun(111); new Thread(p).start(); 3)实现Callable接口(属于JUC并发编程的一部分,工作3~5年才会进入的领域,并发领域.)在此能力不足: 引用此处 与使用Runnable相比， Callable功能更强大些 实现的call()方法相比run()方法，可以返回值 方法可以抛出异常支持泛型的返回值 需要借助FutureTask类，比如获取返回结果Future接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。FutureTask是Futrue接口的唯一的实现类 FutureTask 同时实现了Runnable,Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 4)使用线程池:基本概念:它类似于JDBC连接中的连接池,常量池….不需要每次使用时重复创建和销毁对象.(5)深入多线程的运行逻辑–&gt;多线程的调度和控制在java中,线程一共分为五种状态:创建,就绪,阻塞,运行,死亡.创建: 即创建线程还未调用start(),还没有开始运行线程中的代码;就绪: 线程处于可执行状态,调用start()方法,申请资源.阻塞: （一）、等待阻塞：（二）、同步阻塞：(三）、其他阻塞：运行: 获得cpu分配的资源.执行任务.死亡: 正常执行或异常退出run()方法.该线程生命周期结束. 线程的调度方式:线程终止、暂停、礼让、插队 问二:(1)红绿灯,12306,大数据…是经典的高并发问题.(2)什么是高并发高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。 响应时间：系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量：单位时间内处理的请求数量。 QPS：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数：同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。(3)解决高并发方案1)提升系统的并发能力:增强单机硬件性能 提升单机架构性能2)水平扩展 (4)什么是多线程同步机制及其作用 在多线程的领域中,同步是一个多线程并发的情况下的特殊需求,即同步首先要求在多线程并发的情况下才能发生.多线程同步要求:当一个线程对某内存块A进行操作时,若其他线程同时也需要对内存块A进行操作,则需要等待前一个线程操作完成后才可以进行.同步的”同”,并不是指同时进行,而更多是等待的含义,类似于有共”同”的需要而等待.更多情况下,我们不应该对其拆分,而是应对”同步”整个词进行理解.同步可以理解为生活中的结伴行走的情形:若一位朋友因为手上抱着东西突然慢几步,另一位朋友发现后,则在前方等待一会儿,等他们同步后接过朋友手中的东西,然后一同行走.说到线程的同步,不得不提的就是synchronized关键字.实际上,在大型应用的开发中,一旦涉及多线程的大数据处理,基本上都会用到synchronized进行同步计算.下面将以两个简单的累加运算的示例,查看在多线程的情况下,无同步和有synchronized同步的运行结果的差距.纯手敲,引用李建平编著多线程与大数据处理实战代码: 12345678910111213141516171819202122232425262728293031public class RunWithoutSync&#123; public static int count = 0; public static void main(String[] args)&#123; //创建四个线程,让他们一起跑累计递增计算 Thread increaseValueThread01 =new Thread(new IncreaseWithoutSyncRunnable()); Thread increaseValueThread02 =new Thread(new IncreaseWithoutSyncRunnable()); Thread increaseValueThread03 =new Thread(new IncreaseWithoutSyncRunnable()); Thread increaseValueThread04 =new Thread(new IncreaseWithoutSyncRunnable()); increaseValueThread01.start(); increaseValueThread02.start(); increaseValueThread03.start(); increaseValueThread04.start(); try&#123; Thread.sleep(2000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(RunWithoutSync.count); &#125; &#125; //用于值累加递增的线程public class IncreaseWithoutSyncRunnable implements Runnable&#123; @Override public void run()&#123; for(int i = 0;i &lt; 10000; i++)&#123; RunWithoutSync.count++; &#125; &#125;&#125; //该实例,按照逻辑预期结果应为40000,但由于该实例没有使用同步.因此运行结果有时会出现少于40000的情况. 改进实例.加入同步监控锁及同步关键字synchronized进行累加时候的同步控制.纯手敲,引用李建平编著多线程与大数据处理实战代码: 12345678910111213141516171819202122232425262728293031323334353637383940public class RunWithoutSync&#123; public static int count = 0; public static void main(String[] args)&#123; //创建四个线程,让他们一起跑累计递增计算,并且加入相同的监控锁 //作为同步监控锁 Object monitorLock = new Object(); Thread increaseValueThread01 =new Thread(new IncreaseWithoutSyncRunnable(monitorLock)); Thread increaseValueThread02 =new Thread(new IncreaseWithoutSyncRunnable(monitorLock)); Thread increaseValueThread03 =new Thread(new IncreaseWithoutSyncRunnable(monitorLock)); Thread increaseValueThread04 =new Thread(new IncreaseWithoutSyncRunnable(monitorLock)); increaseValueThread01.start(); increaseValueThread02.start(); increaseValueThread03.start(); increaseValueThread04.start(); try&#123; Thread.sleep(2000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(RunWithoutSync.count); &#125; &#125; //用于值累加递增的线程public class IncreaseWithoutSyncRunnable implements Runnable&#123; private Object monitorLock; public IncreaseWithoutSyncRunnable(Object monitorLock)&#123; this.monitorLock = monitorLock; &#125; @Override public void run()&#123; for(int i = 0;i &lt; 10000; i++)&#123; //同步关键字synchronized进行累加的同步控制 synchronized(monitorLock)&#123; RunWithoutSync.count++; &#125; &#125; &#125;&#125; //该实例,结果应为40000. 多线程锁的介绍本文引用均标明出处.请放心食用.图片也是.emm….路漫漫其修远兮,吾将上下求索.","tags":[]},{"title":"","date":"2021-05-20T09:49:27.077Z","path":"2021/05/20/测量平均值,残差,标准列误差,算术平均测量列误差数据可视化/","text":"python算法需要导入第三方库numpy,pandas,matplotlib数据分析常用库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npimport matplotlib.pyplot as pltdef avg(list_x):#求平均值 avg_x= sum(list_x)/len(list_x) return avg_xdef residual(list_x):#求残差 list1 = []#定义列表 length =len(list_x)#计算长度 for i in range(0,length): list1.append(list_x[i]-avg(list_x))# return list1def standError(list_x):#求标准列误差,算术平均标准列误差 length = len(list_x) sum = 0 for i in range(0,length): sum += list_x[i]**2 stE = np.sqrt(sum/(length-1)) avg_stE = np.sqrt(sum/(length*(length- 1))) return stE,avg_stEflag=1while (flag==1): test_x = input(&quot;请输入n个数据,每个数据用空格隔开: &quot;).split(&quot; &quot;)##依据空格,分片成列表 test_x = list(map(int,test_x))#将字符列表转化为数值列表 print(&quot;该组数据的平均值为: &quot;, avg(test_x)) rs =residual(test_x) print(&quot;该组数据的残差为: &quot;,rs) sE = np.round(standError(rs),5) print(&quot;该组数据的列标准误差和算术平均标准误差为: &quot;,sE) count = len(test_x) x = np.linspace(1, count, count) # 等差数列,从1到count,count个等差数 avg_y = np.logspace(1,1,base=avg(test_x),num=count)#本质avg(test_x)**np.linspace(1,1,count) rs_y = rs sE_y =np.logspace(1,1,base=sE[0],num=count) nsE_y=np.logspace(1,1,base=sE[1],num=count) plt.plot(x, avg_y, label=&#x27;y=avg&#x27;, color=&#x27;red&#x27;, linewidth=2) # 绘图函数,label图的名称,color线条颜色,linewidth线条宽度 plt.plot(x, rs_y, label=&#x27;y=residual&#x27;, color=&#x27;blue&#x27;, linewidth=2) plt.plot(x, sE_y, label=&#x27;y=standError&#x27;, color=&#x27;green&#x27;, linewidth=2) plt.plot(x, nsE_y, label=&#x27;y=nstandError&#x27;, color=&#x27;black&#x27;, linewidth=2) plt.xlabel(&#x27;Times&#x27;) # x轴的名称 plt.ylabel(&#x27;Vol&#x27;) # y轴的名称 plt.title(&#x27;Physical measurement error &#x27;) # 图的标题 plt.legend(loc=&#x27;right&#x27;) # 图例位置 plt.show() flag=int(input(&quot;请输入1或0.输入0退出程序,输入1重新进行数据测试: &quot;))","tags":[]},{"title":"","date":"2021-05-11T11:55:07.753Z","path":"2021/05/11/无符号数对应的真值,原码,补码,反码的理解,二位变形补码运用/","text":"一.原码,补码,反码概念以8位寄存器为例无符号数对应的真值:十进制直接转化为2进制,范围为0~255 原码左边第一位表示正负,其余表示数值.因此有效数值为7位.范围为-127~+127 反码正数:原码=反码负数: 反码=原码除符号位,其余全部取反 补码补码主要针对正负数的混合运算;其中主要针对的是负数.设x&gt;0正数: [+x]原=[+x]补负数: [-x]原&lt;=&gt;除第一位符号位,其余数值位取反+1后为[x]补.(&lt;=&gt;意为可逆,等效于先-1再取反).即除第一位符号位,其余数值位取反+1后为[x]补&lt;&lt;=&gt;&gt;[-x]原 例如1 010[原码]=1 110[补码],可验证,该方法能逆推 1 110[补码]=1 010[原码] 补码主要针对正负数的混合运算;其中主要针对的是负数.举个栗子:D(十进制) H(十六进制) B(二进制)D: 2 + (-2) = 0B: 错误样例来介绍为什么补码针对正负数的混合运算不使用补码的错误性: 2D = 0 000 0010 B(原码) @1 -2D = 1 000 0010 B(原码) @2 @1 + @2 =1 000 0100 显然错误 引出补码的正确性 2D = 0 000 0010 B(原码)=0 000 0010 B(补码) @1 -2D = 1 000 0010 B(原码) =1 111 1110 B(补码)@2 [@1 + @2 ]补码= 0 000 0000(其实为10 000 0000,首位溢出不管)显然正确. 二位变形补码运用你学废了吗?","tags":[]},{"title":"MySQl&&Naicat连接及JDBC","date":"2021-04-25T09:44:18.000Z","path":"2021/04/25/MySQl&&Naicat连接及JDBC1w字史上最全集合/","text":"MySQl&amp;&amp;Naicat连接及JDBC一.MySQl下载官网链接:https://dev.mysql.com/downloads/以windows为例:进入选择第一个版本下载就可. 之后跳转到一个新界面,点击No thanks, just start my download. 下载完成后将他解压到你能找到的地方. 二.初始化配置1.创建my.ini文件 注意:检查后缀名是否显示,是否真的为ini类型 用记事本打开写入: 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=C:\\mysql-8.0.23-winx64# 设置mysql数据库的数据的存放目录datadir=C:\\mysql-8.0.23-winx64\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4 注意:该两项的路径要和你放置的实际路径相同! 2.初始化MySQL使用管理员身份运行CMD，否则权限不够可能导致安装报错. 打开后进入mysql的bin目录 之后执行以下命令: 1mysqld --initialize --console 注意:一定要记住这个随机密码,先将它复制到文本里保存之后执行下列语句: 1mysqld --install [服务名] ###（服务名可以不加默认为mysql） 成功安装mysql服务.如果为:就执行sc delete mysql如果出现其他情况,可能还有cmd没有用管理员身份运行. 接着执行下列语句: 1net start mysql 部署启动完成. 接下来如果使用cmd命令行运行mysql的话,需要配置环境变量,方面我们调用.在此不在赘述. 二.连接Navicat官方链接:https://www.navicat.com.cn/download/navicat-premium该软件为付费软件.小伙伴们各显神通吧…名字随便取,密码为之前保存的随机密码.用户名默认为:root改密码:还是进入musql的bin目录用管理员身份打开cmd执行下列语句: 1mysql -u root -p 输入之前保存的随机密码,回车执行下列语句: 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;; 之后执行: 1exit; 三.JDBC(Java DataBase Connectivity)1.创建表格一定注意字符集选择!!!!之后点击新建表:我创建了三个名称之后打开表就是这个样子: 接下来我们开始JDBC连接首先下载JDBC加载驱动:官方链接https://dev.mysql.com/downloads/驱动下载教程:https://blog.csdn.net/HDZ1821/article/details/104373946下载完毕之后,以idea为例:搜索驱动压缩包的位置,添加完成后点击apply.之后我们就可以进行数据库加载入类: 123Driver接口Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//sun公司提供的加载mysql数据库接口Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;);//加载Oracle数据库接口 mysql驱动5.0版本之后com.mysql.jdbc.Driver改为com.mysql.cj.jdbc.Driver使用了Mysql最新版驱动所以报错新版驱动名字为 driverClass=“com.mysql.cj.jdbc.Driver” 接着创建对象连接mysql数据库 123456-MySQL数据库Connection con = DriverManager.getConnection(&quot;jdbc:mysql://host:port/database&quot;,&quot;user&quot;,&quot;password&quot;);-ORACLE数据库Connection con = DriverManager.getConnection(&quot;jdbc:oracle:thin:@host:port:databse&quot;,&quot;user&quot;,&quot;password&quot;); 以mysql-Navicat为例:其中host为本机地址,默认是localhostport 端口默认3306database 为数据库名称.user为用户名,默认rootpassword为数据库密码.例如: 1234567891011121314151617import java.sql.*;public class Main &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//加载JDBC驱动 Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;); String sql = &quot;insert into yuanjie (name,number,time) values (?,?,?)&quot;;//占位符防止sql注入 PreparedStatement ps = con.prepareStatement(sql); ps.setObject(1,&quot;陈晨&quot;); ps.setObject(2,&quot;1008611&quot;); ps.setDate(3,new java.sql.Date(System.currentTimeMillis())); ps.execute(); &#125;&#125; 注意:原因是:本人用最新版本的mysql数据库 1DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctest&quot;,&quot;root&quot;,&quot;123456&quot;); 必须在数据库名称后面加上?serverTimezone=UTC 1DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbctest?serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123456&quot;); 运行上面的例子:成功!","tags":[{"name":"mysql","slug":"mysql","permalink":"https://yuanjiejiahui.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://yuanjiejiahui.github.io/tags/sql/"},{"name":"java","slug":"java","permalink":"https://yuanjiejiahui.github.io/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://yuanjiejiahui.github.io/tags/JDBC/"}]},{"title":"认识自我,准确定位","date":"2021-04-24T09:44:18.000Z","path":"2021/04/24/认识自我准确定位/","text":"认识自我,准确定位https://zhidao.baidu.com/question/2054734354381468267.html苏格拉底说：“发现你自己。”每个人都独一无二，但要独树一帜，人需要清楚地认识自己。 我们的眼永远是向外看的，但世间的高峰不止千仞，世间的绝美也无法穷尽，要实在地从中挑出自己适合的，去攀缘，去欣赏。怎样挑选？这就需要我们开一扇心窗以自鉴。只有明辨自己的内心，理想的天上泉才可以醍醐灌顶，催生心间树叶最别具一格的脉络。 认清自己，我们首先要摸准自己的潜能。潜能像一扇虚掩的门，不去敲开，你永远看不懂背后的光芒。郭沫若先生学生时代的成绩单上，只有数学成绩屡屡名列前茅，但他若从此毕生追寻数学而背离自身内心，抛弃文学潜力，很难想象他还能成为名家，幸亏郭老认清了自己，推开了文学的潜能之扉，他似一道惊雷炸响文坛。 当目标确立，我们便能轻装上阵，沿潜能之路前进，向顶峰攀索。但正如通向山顶的山路不可能笔直，我们的前进无疑也会遇到奇险的“十八弯”。然而我们如若认清自我，明辨内心，就总能找到适合自己的路和方向，总会有风雨之后的“云销雨霁，彩彻区明。”遥想当年，红军被围，九死一生的局面，先辈烈士们不也抱着“只要主义真”的信念，认清了自身的不足与优势，认清了前路，完成了“三军过后尽开颜”的壮举吗？ 认识自我可以帮我们登顶，但在绝顶安营扎寨，如若不能以澄明的心守住自我，不断明辨内心，还是会有滑落的危险。如果能认清这时的自我，如果依旧清醒，牛顿晚年放弃自然科学之惜又怎会发生？唐玄宗“婉转额眉马前死”的伤痛又怎会造成？关闭心窗不再向内看，我们的心中汪泉就变成了死水，终究逃不脱枯竭腐朽的一天。不是吗？ 是啊，朋友。我看见你在点头冥想。去拜访内心那干净明亮的地方，去认清自我吧。不要做放弃奔跑的兔，不要做留恋陆地的天鹅。时时审视自己的内心，我们走出的才不是别人的路，喊出的才会是自己的声音，拥有的才是那份“无意苦争春”的旷达。","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"","date":"2021-04-22T23:55:35.494Z","path":"2021/04/23/如何看待中科院自动化所的博士论文致谢_ (1)/","text":"如何看待中科院自动化所的博士论文致谢?近日，中国科学院自动化所一博士论文的致谢部分在网上引发热议。作者在《致谢》中回顾自己如何一路走出小山坳、和命运抗争的故事，打动了大批网友。黄国平今日独家发文，讲述自己成长经历，并向网友留言和朋友关心表示歉意和谢意。他在文中称，网络流传的致谢是被人节选后发布到网上的，现将完整版本附后（隐私相关的敏感信息已被隐藏）。在黄国平附上的致谢完整版本中，已将相关人员姓名隐去。https://www.zhihu.com/question/454961393/answer/1840547150","tags":[]},{"title":"屌丝看完,泪流满面(反省篇)","date":"2021-04-21T10:44:18.000Z","path":"2021/04/21/屌丝看完，泪流满面（反省篇）/","text":"屌丝看完,泪流满面(反省篇)–鱼C工作室你学习一般，考上了现在的这个学校，成绩不算好，拿不到校奖国奖，自习不规律上课不常听，考试全靠突击，同学帮一把也能考到七八十分。 你家境一般，父母都是普通员工，在这个城市一个月生活费一千二，没事下下馆子，一个月添一件衣服，想买台相机要等几个月，经常要咬咬牙才能买双自己喜欢的鞋。 你特长一般，不会吉他不会钢琴不会跳舞不会画画，想学摄影却不会PS，想上台演出却没信心，学校晚会比赛的时候，你经常站在台下的人群里而不是台上的聚光灯下。 你长相一般，不算英俊或者不算美丽，身材不算臃肿但是也没什么肌肉或者没什么曲线，平时只是稍稍打扮一下，容貌看上去并不出众，只能算整洁，你开玩笑的称自己是千万屌丝之一。 你的生活感情也是一般，有时候会遇见自己心仪的那个TA，但是总抓不住机会，眨眼间TA就被其他人俘获，你就开始伤心抱怨，但是几天之后又开始寻找新的TA。 总之，你没有什么特别的地方，就和周围的千万个你一样。但是，你和其他的你一样，渴望飞翔渴望自由。 你不甘心拿不到奖学金，看见别人得奖的时候你会说完全是突击的结果，你开始上自习，坚持了一个星期。 你不甘心自己的父辈平平，会批判会讽刺自己周围的官二代富二代，立志自己要努力好让自己的孩子成为富二代，你坚持了一个星期。你不甘心自己什么都不会，你开始学吉他买轮滑鞋借PS的书对着镜子微笑说自己有信心，你坚持了一个星期。 你不甘心自己没身材没长相，你开始健身长跑练肌肉练线条，你坚持了一个星期。 你不甘心自己没有伴侣，你决心自己洗心革面重新做人，你删掉电脑里的**你收拾起床上的懒人桌你仔细的洗了个澡你为自己化了妆，决定出去走走开始新的生活，你坚持了一个星期。 然后，这一个星期之后，你还是和周围千万个你一样，你还是和一星期前的自己一样。 少年，你来到现在的学校，是为了什么？ 你逛人人，看见人人上的状态说“二十岁是人生最美好的时光，不应该局限在学校里教室里，应该享受生活”，于是你相信了。 你看见人人上状态说“这样的年纪本应是率性的，而我身边的太多人在考虑诸如家庭类型、毕业发展方向、是否异地、价值观等问题。这导致本来深深互相喜欢的两个人错失了一段美好的时光，他们所谓爱情的忧伤不过都是自己在娇柔做作”，于是你相信了。 你看见人人上的日志说“国奴常用的10句话，被洗脑的**也常说”，于是你也相信了。 于是你觉得，二十岁的你就该“享受生活”“随心所欲”，享受“人生中最后的自由时光”。 于是你觉得，二十岁的你就该“快乐的去恋爱”，“仔细享受和TA在一起的一分一秒，其他什么都不去想” 于是你觉得，二十岁的你就该“风华正茂挥斥方遒”，“指点江山激扬文字” 少年，请允许我猜测一下你的未来。 现在的你，用着父母的血汗钱，买着NB的包PUMA的板鞋捷安特的ATX佳能的5D2和爱疯的4S，吃着仟吉的冷茶DQ的暴风雪银鲨的海鲜星巴克的咖啡，经 常去酒吧去茶楼去看你所谓的众生百态积累你所谓的生活经验。 大学四年，你考研意外之外的落榜，因为双选会时候公司都不中意的缘故，你在毕业时候还没有找到 心仪的工作，收拾了行李回家，父母和你说去试试这个或者那个工作吧，你说这工作太简单了不适合我，你去更好的企业寻找机会，却因为表现平平被置之门外。每天都是这样，没能力却不甘心，最终变成啃老族。 现在的你，和TA恩恩爱爱，每天黏在一起，上课TA会等你下课TA会接你，午饭你们一起吃晚 饭之后还会一起散步，TA说未来怎么办你说不要考虑未来认真过好现在。 不幸运的话，几个月后TA会觉得你在玩弄TA的感情而离开你，留下你独自一人空悲切 反复问自己究竟哪里不对。幸运的话，你们一直谈到毕业，最后你会悔恨自己不够优秀没能去TA所在的城市读研或者工作，带着不舍和悔恨分手。 鱼C工作室 2013-09-26现在的你，在网上看见自己赞同的观点会全力支持，看见自己不认同的观点会全力否定。你觉得现在正值当年的自己就该这样敢于说出自己的心声。最后，你的观点完全来自于网络，当你想说话的时候，你才发现忘记了自己的声音，自己已经失去了原来敏锐的判别能力。 少年，我只想问你一个问题，现在的你二十岁的你有什么资本。 你成绩一般但是你有很多自由时间去支配，你觉得很欣慰。 你家境一般但是你的要求爸妈都会满足，你觉得很欣慰。 你特长很少但是有一个擅长的，靠着这点你在周围的聚光灯下过的很满足，你觉得很欣慰。 你没有伴侣但是有很多朋友会喊你喝酒唱歌出去逛街，你觉得很欣慰。 现在的你很欣慰，时间久了呢？ 生活是一盘棋，需要用心去下，当你有资本的时候你才能赢。是的，我能理解你要自由你要自己的天空。但是我不知道你的父母老师有没有教育过你，自由也是要付出代价的吗？ 少年，我不知道你是怎么了。 你想要好的成绩但是你不去学习。 你想要富裕的生活但是你不去奋斗。你想要健康的身体但是你不去锻炼。你想要自己称心如意的生活，但是你从来没有想过改变自己。 少年，你知道未来的意义吗？我承认现在的每一天都是未来必不可少的一部分，但是你有认认真真的考虑过自己要一个什么样的未来吗？你有仔仔细细的考虑过怎么样去到达这个未来吗？ 你在犹豫，你在抱怨，你在彷徨，你在悲叹社会的不公，但是你有什么权利有什么资本要求你所在的环境所处的世界为了你去改变？现在的你只是千千万万的你中微不足道的一个，少了你地球还是一样会转。 少年，你知道责任两个字怎么写吗？我知道你很喜欢自由自在很喜欢享受你的生活。是啊，二十岁的你再不玩就永远没机会了，这也是你所相信的。我敢打赌一定很久没人和你说过“吃得苦中苦方为人上人”这句话了吧。 当你谈论飞翔的时候，你是不是忘记了地心引力的存在。二十岁的少年，爱玩你去玩吧 我过了二十岁的年纪，我还有未来，不陪你了。","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"Hello World","date":"2021-04-17T09:35:41.681Z","path":"2021/04/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"致自己","date":"2021-03-19T09:44:18.000Z","path":"2021/03/19/致自己/","text":"** 致自己**—渊洁幼时， 因为家里的条件， 我从小就没有什么玩具或零食， 经常被别人欺负， 我从不抱怨。 因为生活不会偏袒谁， 是我的终究是我的。 学生时， 妈妈告诉我， 你的任务以学习为主， 我不会干涉你的兴趣爱好， 你只要努力就好， 不要给自己施加压力， 因为你努力就会有回报， 如果难过就给自己一个小时缓解， 如果气愤就放一首音乐听， 如果开心就毫无顾忌的笑， 如果被嘲笑不要反骂， 嘴长在别人身上你堵不了， 如果被欺负就忍， 忍了三次再反抗， 如果讨厌别人， 就将它埋藏在心底， 如果被别人讨厌， 就别理他们， 因为你自己就是最棒的人。 每天早上醒来对镜子里的自己说， 我是最棒的， 然后笑一下， 因为快乐的日子不多， 讨厌的人不少， 伤心的事数不完， 何必要让自己那么辛苦呢?长大也许就是：学会了把亲情放在第一位把友情放在第二位把爱情放在够不到的位置；学会了不和父母顶嘴，学会为了维护友谊让步；学会了不想着依赖别人，做好自己，让别人依赖你；学会了认清自己，不是很好，也不算坏，不把头扬的很高，也不拿眼睛盯别人的脚；学会把喜欢的人放在心底，默默的不张扬。芸芸众生，凡夫俗子，平平淡淡，一身轻舒","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"感遇","date":"2021-03-18T09:44:18.000Z","path":"2021/03/18/感遇/","text":"** 感遇**—渊洁夫天地者，万物之逆旅也；光阴者，百代之过客。人生很短，朝闻道而夕死。人生很长，耄耋之年犹不衰。在这既短又长的一生中，我们总会经历许许多多的事，然后因其中一些而后悔。然而，很多我们念念不忘的事就在我们念念不忘的过程中过去了。直到很多年后，日近觚棱时才隐约想起复又一笑而过。但当年刻骨铭心的悔恨已随风而逝，一同消散的还有曾经的意气风发。或许还要加上一句感怀“若是那时……现在就会……”可是，生活没有“若是”，它只会磨平你的棱角。有些事，一旦错过就是一生。我总说生命如花，应绽放在最骄傲的时刻。正所谓，只有看到落红满地，才能体验到繁花似锦的宝贵，然而一切已成往事。是了，繁花似锦再如何宝贵都已不复存在，只能更添悔恨，徒留遗憾。故，若是心中有志，那便唯傲然前往。无论风雨，虽九死其尤未悔。————@Dawn","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"人往低处走,谦逊明智怡神","date":"2021-03-17T09:44:18.000Z","path":"2021/03/17/人往低处走，谦逊明智怡神/","text":"** 人往低处走，谦逊明智怡神**https://www.fwsir.com/fanwen/HTML/fanwen_20130513203607_216430.html 中国有句世代相传的老话：”人往高处走，水往低处流。”这句话鼓舞了一代代炎黄子孙立大志、干大事，摆脱了贫困的处境。高处自有高处的好处：高处意味着荣华富贵，高处意味着炙手权势，高处意味着封妻荫子，高处意味着吃香喝辣。 不过，低处也有低处的优势。处在低处的人心无旁骛，因而能专心致志、全力以赴地对待手头的工作，更容易取得成功；处在低处的人与世无争，因而志向高雅，恬淡脱俗，更直接地达到了人生的至高境界。走向低处不是失败的代名词，而是一种理智的人生选择。 伊吕两衰翁，历尽穷通；南阳诸葛亮，也曾躬耕陇亩。正所谓厚积而薄发，处在低处的人知道怎样顺应时势，知道怎样充实自己，以便在最佳时刻展露才华。大地处在低处，厚德以载万物，没有人不承认它的辽阔；大海处在低处，宽容以纳细流，没有人不承认它的深邃。正是”龙潜海底，不飞则已，一飞冲天；凤落岐山，不鸣则已，一鸣惊人”。人往低处走，不是盲目乱走，只是绕了个弯，时机一到，便能登上成功的顶峰。 鬼谷子隐居深山，但声名远扬，七国无人不知；陶渊明把酒东篱，但文章诗作流传千古；文王拘而演《周易》；仲尼厄而作《春秋》。处在低处的人不是不争，而是知道什么该争，什么不该争；处在低处的人不是不为，而是知道什么能为，什么不能为。处在低处，他们依旧与天斗，与命斗，最终献给世人的是他们的心血。人往低处走，恰恰是人生的高尚境界，成功孕于此，荣耀孕于此。 乾卦上九曰：”亢龙，有悔。”龙飞得太高了，终会招来祸端；人走得太高了，终会觉得高处不胜寒。当人走到人生的制高点，往往随之而来的是不得不走向低处，退而让贤是明智之举。人是应当乐于走向低处的，因为只有处在低处，才能目标更明确地冲击高处。退下来并不是甘于失败，而是要学会怎样在跌倒处爬起来。 在重物质而轻意识、重金钱而轻情理的今天，越来越少的人愿意走向低处。高调做事，低调做人的准则更是被忘得一干二净。但人往低处走并不是放弃人生的目标一味忍让，而是为了走向更高处而采用的一种手段！","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"不畏将来,不念过往","date":"2021-03-16T09:44:18.000Z","path":"2021/03/16/不畏将来,不念过往/","text":"** 不畏将来,不念过往** 人生的最大特点就是，留不住。 不管是什么东西，都留不住。 不管珍贵的，美好的，都留不住。 我们拥有，只是暂时。房子是暂时，工作是暂时。存款是暂时，朋友，也是暂时。 我们去过了不少地方， 然而这些地方如今都不在我们跟前。 我们经历过不少困难， 然而这些困难如今都跑哪去了。 都不在了。 唯独从我们的眼皮子底下溜走， 在我们脚跟下面退后。 想到这里，我心冰凉。 本以为以前真爱的地方可以长久居住。 没想到仅两年时间就物是人非。 熟悉的地点，换了一批人。 从前的时候不见了， 高楼替代了村庄。 还有什么值得去炫耀。还有什么。 金银财宝，功名利禄。出身高贵，奢侈成风。 但时间啊它不长眼睛。 它分不清高贵者与低下者。 它使少年变成青年， 它使美女长出皱纹。 故此好好享受吧，现在欢乐的时光。 因为以后年老代替了轻狂。 疲惫代替轻松。 那些时辰一过就不会再有， 仿佛那些美丽的地方， 经过一次，就再也不能重新经过。 一条河流不能踏两次。 一条河流只能踏一次。 所以尽管悲伤，但不后悔。 尽管垂首，但却微笑。 多年以后，我撒手而去， 地上留下我的千万篇文章、诗词。 那时，我将很高兴的笑去。 因为，我把我的思想给留住了。 它们仿佛天使一样在这世上不走。 长久存留。 所以，我不追求留不住的东西。 我唯一追求可以留住的东西。 这可以留住的东西就是， 灵魂、思想、诗、和文。","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"生于这个时代，不屈于这个时代的命运","date":"2021-03-15T10:44:18.000Z","path":"2021/03/15/生于这个时代，不屈于这个时代的命运/","text":"** 生于这个时代，不屈于这个时代的命运**我们试图掌控命运，到头来却总被命运捉弄；我们试图探讨人生，到头来却发现人生如梦；我们试图张扬个性，到头来却往往被群体同化。“人生不如意，十之八九” ，既然无法掌控命运，我们就顺其自然，找到内心的自我，做到不迷失自己，达到内心的平和！生命简单一点，快乐也会长久一点。 要懂得忘却。人生最大的痛苦缘自追求完美，要知道，真正的光明并非没有黑暗的时刻，只是永远不为黑暗淹没罢了。我们的生活也是一样，忍着疼痛奔跑，带着泪光微笑，这才是真正的生命。 要懂得放弃。人生如戏，每个人都是自己生命中的唯一导演，只有懂得放弃的人才能彻悟人生，笑看人生，始终拥有一个好的心情。“舍得舍得” ，有舍才有得。 要懂得欣赏。用欣赏的眼光看待人和事，我们会更幸福。其实，每个人身上都有优点，也都有缺点。我们何必要带着放大镜看人，而不带着望远镜去欣赏呢？ 岁月的流逝，生活的繁琐，现实的诸多不易给人越来越多的压力，没有驻足品味的闲暇，少了冥想沉思的情致。一个人的情绪受环境的影响，这是很正常的，只有心里有阳光的人，才能感受到现实的阳光，快乐是一种生活态度，快乐是一种心绪。不要把自己禁锢在忧愁的厚茧里，美化生活，欣赏生活，人生到处都会有亮丽的风景。 我们无法躲避每一个平淡的日子，也无法回避平淡日子里流水帐一样的忙碌。每个人都有自己的活法，只要能够发现自我，并且在身体与心灵中保持自我，并最终超越自我，即使无人喝彩也会有所收获。活出平凡真实的自己。人生在世，笑是一种潇洒，哭也是一种潇洒，只要发自肺腑，定会酣畅淋漓。 在这复杂的社会中我们要学会处变不惊，不要让自己迷失了方向，伤心和委屈的时候，就嚎啕大哭。哭完洗洗脸，挤出一个微笑给自己看。给自己一个远大的前程和目标。记得常常仰望天空，但也不要忘记仰望天空的时候也看看脚下。 平凡的日子里演绎平凡的自己，虽说平凡的人只要努力就能影响世界，但不要刻意地去追求什么，用自己的善良品质和快乐的心情，去做真实而平凡的自己。这样的日子有思念相随，有开心相伴，可谓天马行空，你会为此而感到自豪，感到惬意，也活得真实轻松而又安然。 我们都是普普通通的人，每天在行色匆匆的人流中穿行在嘈杂喧嚣的环境中忙碌。我们渴望在疲惫的奔波中获得轻松的释放，在夜深人静的安宁中，为自己莫名的孤独找到平静的理由，我们甚至期待自己平平淡淡的生活能出现向往已久的辉煌，幻想着以自己平庸的能力创造出非凡的成绩。我们不停地在为我们的心灵祈祷着，因为只有心灵的不懈和满足，才能使我们感受到人活着幸福的意义。 我生来就如同天上星，生来就要光芒万丈，普照大地！如果这光不够强，这火不够烈。那我愿尽其所有，发挥自己所有的光和热，照亮世间一切灰暗。","tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"}]},{"title":"水果摊售货系统","date":"2021-03-15T09:44:18.000Z","path":"2021/03/15/java水果摊增删改查(集合与IO流的配合)/","text":"项目名水果摊售货系统项目描述该系统类似于超市收银系统,由收银员操作,包括添加商品进购物车,结账以及找零控制台界面具体功能 查看水果列表 购买水果可以是输入水果名,也可以是输入水果编号 查看购物车 结账 退出 要求使用数组或集合完成数据存储使用IO流实现数据的读入和写出 我打算分为两个包1.fruitsMenu 2.IOmreq一.fruitsMenu1.主函数包代码如下: 12345678910111213141516171819package fruits_menu;public class Fruits_main &#123; public static void main(String[] args) &#123; System.out.println(&quot;This is fruits shop!&quot;); System.out.println(&quot;Welcome to our shop!&quot;); System.out.println(&quot;Please enter what you need&quot; +&quot; to query&quot;); System.out.println(&quot;fruits menu:&quot;); while(true) &#123; Fruits_menu.menu();//调用主菜单 Menu_input.input();/*调用选择输入,调用谁的方法,创建哪个类的对象,不能调用无对象的方法.静态方法直接类名.方法*/ &#125; &#125; public static void main() &#123; &#125;&#125; 2.主菜单 123456789101112131415161718192021222324package fruits_menu;import java.text.SimpleDateFormat;import java.util.Date;//使用 Date 类及 SimpleDateFormat 类的 format(date) 方法来输出当前时间public class Fruits_menu &#123; public static void menu() &#123; // TODO Auto-generated constructor stub System.out.println(&quot; ________ ________ ___ ___ ___ _________ ________ \\n&quot; + &quot;|\\\\ _____\\\\\\\\ __ \\\\|\\\\ \\\\|\\\\ \\\\|\\\\ \\\\|\\\\___ ___\\\\\\\\ ____\\\\ \\n&quot; + &quot;\\\\ \\\\ \\\\__/\\\\ \\\\ \\\\|\\\\ \\\\ \\\\ \\\\\\\\\\\\ \\\\ \\\\ \\\\|___ \\\\ \\\\_\\\\ \\\\ \\\\___|_ \\n&quot; + &quot; \\\\ \\\\ __\\\\\\\\ \\\\ _ _\\\\ \\\\ \\\\\\\\\\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\_____ \\\\ \\n&quot; + &quot; \\\\ \\\\ \\\\_| \\\\ \\\\ \\\\\\\\ \\\\\\\\ \\\\ \\\\\\\\\\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\ \\\\|____|\\\\ \\\\ \\n&quot; + &quot; \\\\ \\\\__\\\\ \\\\ \\\\__\\\\\\\\ _\\\\\\\\ \\\\_______\\\\ \\\\__\\\\ \\\\ \\\\__\\\\ ____\\\\_\\\\ \\\\ \\n&quot; + &quot; \\\\|__| \\\\|__|\\\\|__|\\\\|_______|\\\\|__| \\\\|__| |\\\\_________\\\\\\n&quot; + &quot; \\\\|_________|\\n&quot;); SimpleDateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//设置日期格式 System.out.println(df.format(new Date()));// new Date()为获取当前系统时间 System.out.println(&quot;1.View the fruit list.&quot;); System.out.println(&quot;2.To buy fruits.&quot;); System.out.println(&quot;3.View shopping cart.&quot;); System.out.println(&quot;4.Delete Fruits&quot;); System.out.println(&quot;5.Exit.&quot;); &#125;&#125; 3.输入功能 123456789101112131415161718192021222324252627package fruits_menu;import I0mreq.IOread;import java.io.IOException;import java.util.Scanner;public class Menu_input &#123; public static void input()&#123; Scanner scanner =new Scanner(System.in); int user = scanner.nextInt(); switch(user) &#123; case 1: Fruits_List.List();break; case 2: Fruits_buy.buy();break; case 3: Fruits_cart.cart();break; case 4: try &#123; Fruits_clearing.clearing(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; break; case 5: System.out.println(&quot;Thanks for your patronage!&quot;); IOread.read(); System.exit(0);/*status是状态码,0表示正常退出程序,其他值表示异常退出,return 只能退出方法*/ &#125; &#125;&#125; 4.第一个功能水果列表展示 1234567891011121314151617181920212223242526272829303132333435363738package fruits_menu;import java.util.Scanner;public class Fruits_List &#123; static double apple=5.0,pear=6.0,banana=7.0,grape=10.0; public static void view()&#123; System.out.println(&quot;Fruits\\t\\tUnit&quot;); System.out.println(&quot;1.apple\\t\\t&quot;+apple+&quot;yuan/0.5kg&quot;); System.out.println(&quot;2.pear\\t\\t&quot;+pear+&quot;yuan/0.5kg&quot;); System.out.println(&quot;3.banana\\t&quot;+banana+&quot;yuan/0.5kg&quot;); System.out.println(&quot;4.grape\\t\\t&quot;+grape+&quot;yuan/0.5kg&quot;); System.out.println(&quot;----------------------------&quot;); &#125; public static void List() &#123; view();//水果单价数据表 System.out.println(&quot;if you enter 1,you will return to the main menu&quot;); System.out.println(&quot;if you enter 2,you will into your select buy&quot;); Scanner user = new Scanner(System.in); int Use =user.nextInt(); if(Use==1) &#123;//调用主菜单 Fruits_menu.menu(); while(true) &#123; Menu_input.input();/*调用选择输入，调用谁的方法，创建哪个类的对象,不能调用无对象的方法.静态方法直接类名.方法*/ &#125; &#125; else if(Use==2) &#123;//进入购买界面 Fruits_buy.buy(); &#125; &#125;&#125; 5.水果数据录入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.vector.pojo;public class FruitsData &#123; //定义ID private String id; //定义名称 private String name; //定义数量 private double unit; private double weight; private double price; public FruitsData(String id, String name, Double weight,double unit) &#123;//无参构造器是必要的，所以定义有参构造器，还要再写一遍 super(); this.id = id; this.name = name; this.weight = weight; &#125; public FruitsData() &#123;//无参构造器是必要的，所以定义有参构造器，还要再写一遍 super(); // TODO Auto-generated constructor stub &#125; public void setId(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125; public double getWeight() &#123; return weight; &#125; //获取价格 public void setUnit(double unit)&#123; this.unit =unit;&#125; public double getUnit()&#123; return unit;&#125; public void setPrice(double price)&#123;this.price = price;&#125; public double getPrice()&#123; return price; &#125;&#125; 6.购买功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package fruits_menu;import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.Scanner;import I0mreq.CreateFile;import I0mreq.IOwrite;import com.vector.pojo.FruitsData;public class Fruits_buy &#123; static ArrayList&lt;FruitsData&gt; list = new ArrayList&lt;&gt;();//容器存放某种水果及其属性 static void buy() &#123;//添加水果系统 CreateFile.file();//创建文件 Fruits_List.view();//调用水果单价数据表 System.out.println(&quot;Please select the item you &quot; + &quot;want to buy,and please input fruits number or name&quot;); System.out.println(&quot;Please input enterKey to confirm.&quot;); addFruits(list); IOwrite.write(list); System.out.println(&quot;If you enter 1,you will return to the main menu&quot;); System.out.println(&quot;If you enter 2,you will into your cart&quot;); Scanner user = new Scanner(System.in); int User = user.nextInt(); if (User == 1) &#123;//调用主菜单 Fruits_menu.menu(); while (true) &#123; Menu_input.input();/*调用选择输入,调用谁的方法,创建哪个类的对象,不能调用无对象的方法.静态方法直接类名.方法*/ &#125; &#125; else if (User == 2) &#123;//进行购物车筛选界面 Fruits_cart.cart(); &#125; &#125; public static void addFruits(ArrayList&lt;FruitsData&gt; arrayList) &#123; Map&lt;String, Double&gt; fruitsBuy = new HashMap&lt;&gt;();//map实现键值对应 fruitsBuy.put(&quot;1&quot;, Fruits_List.apple); fruitsBuy.put(&quot;2&quot;, Fruits_List.pear); fruitsBuy.put(&quot;3&quot;, Fruits_List.banana); fruitsBuy.put(&quot;4&quot;, Fruits_List.grape); Scanner sc = new Scanner(System.in); Map&lt;String, String&gt; Name = new HashMap&lt;&gt;();//map实现键值对应 Name.put(&quot;1&quot;, &quot;apple&quot;); Name.put(&quot;2&quot;, &quot;pear&quot;); Name.put(&quot;3&quot;, &quot;banana&quot;); Name.put(&quot;4&quot;, &quot;grape&quot;); System.out.println(&quot;Please input fruits id.&quot;); String id = sc.nextLine(); System.out.println(&quot;Please input fruits weight.&quot;); double weight = sc.nextDouble(); FruitsData s = new FruitsData(); s.setId(id); s.setName(Name.get(id)); s.setWeight(weight); s.setUnit(fruitsBuy.get(id)); s.setPrice(weight * fruitsBuy.get(id)); arrayList.add(s);//引用类型 集合追加 System.out.println(&quot;Added fruit successfully!&quot;); System.out.println(&quot;if you want to exit,please input enter&quot;); System.out.println(&quot;input other keyboard is continue.&quot;); sc.nextLine(); if (!sc.nextLine().equals(&quot;&quot;)) &#123;//输入回车退出 addFruits(arrayList); &#125; &#125;&#125; 7.购物车功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package fruits_menu;import java.util.Scanner;import I0mreq.IOread;import com.vector.pojo.FruitsData;public class Fruits_cart &#123; public static void cart()&#123; IOread.read();//读取文件 System.out.println(&quot;If you press 1,you could enter the down layer.&quot;); System.out.println(&quot;If you press 2,you could enter main menu!&quot;); System.out.println(&quot;If you press 3,you could enter delete function!&quot;); System.out.println(&quot;If you want delete or modify data,you could enter other.&quot;); Scanner scanner = new Scanner(System.in); int user = scanner.nextInt(); switch (user) &#123; case 1: System.out.print(&quot;Please pay:&quot;); double sumMoney = 0; for(int i=0;i&lt;Fruits_buy.list.size();i++)&#123; FruitsData f = Fruits_buy.list.get(i); sumMoney= sumMoney + f.getPrice(); &#125;//统计金额 System.out.println(sumMoney); Scanner sc = new Scanner(System.in); double s =sc.nextDouble(); if(s==sumMoney) &#123; IOread.read(); System.out.println(&quot;Pay&quot;+sumMoney); System.out.println(&quot;Order has been confirmed!&quot;); &#125; else &#123; System.out.println(&quot;Payment failure.&quot;); Fruits_main.main(); &#125; break; case 2:Fruits_menu.menu(); Menu_input.input();/*调用选择输入,调用谁的方法,创建哪个类的对象,不能调用无对象的方法.静态方法直接类名.方法*/ break; case 3: Fruits_clearing.clearing(Fruits_buy.list); break; default:System.out.println(&quot;Sorry,you input number is error!&quot;); &#125; if(user!=1)&#123; System.out.println(&quot;Order has been confirmed!&quot;); IOread.read(); &#125; &#125;&#125; 8.删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445package fruits_menu;import I0mreq.IOread;import I0mreq.IOwrite;import com.vector.pojo.FruitsData;import java.io.IOException;import java.util.ArrayList;import java.util.Scanner;public class Fruits_clearing &#123; public static void clearing() throws IOException &#123; Scanner sc = new Scanner(System.in); IOread.read(); System.out.println(&quot;请输入要删除的水果ID: &quot;); String id = sc.nextLine(); for (int i = 0; i &lt; Fruits_buy.list.size(); i++) &#123; FruitsData f = Fruits_buy.list.get(i); if(f.getId().equals(id))&#123; Fruits_buy.list.remove(i); IOwrite.write(Fruits_buy.list); System.out.println(&quot;删除成功&quot;); return; &#125; &#125; System.out.println(&quot;找不到要删除的水果ID!&quot;);&#125; private static void write(ArrayList&lt;FruitsData&gt; list) &#123; // TODO Auto-generated method stub &#125; private static void print(ArrayList&lt;FruitsData&gt; list) &#123; // TODO Auto-generated method stub &#125; public static void clearing(ArrayList&lt;FruitsData&gt; list) &#123; // TODO Auto-generated method stub &#125; &#125; 二.第二部分IOmreq1.创建目录 123456789101112131415package I0mreq;import java.io.File;public class IOmkdirs &#123; public static void mkdirs() &#123; //创建目录文件夹 File FruitDatabase = new File(&quot;C:/MyPro01_fruits/FruitDatabase&quot;);//设置目录路径 FruitDatabase.mkdirs();//创建目录 &#125; &#125; 2.创建文件 12345678910111213141516package I0mreq;import java.io.File;public class CreateFile &#123; public static void file() &#123; IOmkdirs.mkdirs();//创建path目录 try &#123; File file = new File(&quot;C:/MyPro01_fruits/FruitDatabase/Data.txt&quot;);//设置文件路径 file.createNewFile(); //创建文件 &#125; catch (Exception e) &#123;//捕捉异常 // TODO: handle exception e.printStackTrace();//深度分析异常产生的原因并打印出来 &#125; &#125;&#125; 3.写入文件 123456789101112131415161718192021222324252627282930313233343536package I0mreq;import java.util.ArrayList;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import com.vector.pojo.FruitsData;public class IOwrite &#123; public static void write(ArrayList&lt;FruitsData&gt; list)&#123; BufferedWriter fos = null; try &#123; // true表示内容会追加到文件末尾；false表示重写整个文件内容。 fos = new BufferedWriter(new FileWriter(&quot;C:/MyPro01_fruits/FruitDatabase/Data.txt&quot;));//字符缓冲流 for (int i = 0; i &lt; list.size(); i++) &#123; FruitsData f = list.get(i); fos.write(f.getId()+&quot; &quot; + f.getName() + &quot; &quot; + f.getUnit() + &quot; &quot; + f.getPrice()); fos.newLine(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fos != null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.读取文件 123456789101112131415161718192021222324252627282930package I0mreq;import java.io.FileInputStream;public class IOread &#123; public static void read()&#123; FileInputStream fis = null;//全局变量,fileInputStream字节流.可能会编码异常.FileReader字符流 try &#123; fis = new FileInputStream(&quot;C:/MyPro01_fruits/FruitDatabase/Data.txt&quot;);//创建对象 StringBuilder sBuilder = new StringBuilder();//字符输出 int temp = 0; while((temp = fis.read()) != -1) &#123;//read是一个字符字符的读,读完为-1 sBuilder.append((char)temp);//append读取追加,sB动态数组 &#125; System.out.println(sBuilder); &#125;catch (Exception e) &#123;//捕获异常结果 e.printStackTrace(); &#125;finally &#123;//绝对执行 try &#123; if(fis != null) &#123; fis.close();//关闭流对象 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125; &#125; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"https://yuanjiejiahui.github.io/tags/java/"},{"name":"项目开发","slug":"项目开发","permalink":"https://yuanjiejiahui.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}],"categories":[],"tags":[{"name":"美文","slug":"美文","permalink":"https://yuanjiejiahui.github.io/tags/%E7%BE%8E%E6%96%87/"},{"name":"感悟人生","slug":"感悟人生","permalink":"https://yuanjiejiahui.github.io/tags/%E6%84%9F%E6%82%9F%E4%BA%BA%E7%94%9F/"},{"name":"mysql","slug":"mysql","permalink":"https://yuanjiejiahui.github.io/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://yuanjiejiahui.github.io/tags/sql/"},{"name":"java","slug":"java","permalink":"https://yuanjiejiahui.github.io/tags/java/"},{"name":"JDBC","slug":"JDBC","permalink":"https://yuanjiejiahui.github.io/tags/JDBC/"},{"name":"项目开发","slug":"项目开发","permalink":"https://yuanjiejiahui.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"}]}